Index: 3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"std_lib_inc.h\"\r\n\r\n// Fehlerklassen\r\nclass BereichsFehler{};\r\nclass EingabeFehler{};\r\nclass UnzulaessigeEingabe{};\r\n\r\n// Schlangenklassen\r\nclass Schlangenglied{\r\npublic:\r\n    int posX{0};\r\n    int posY{0};\r\n};\r\n\r\nclass Position {\r\npublic:\r\n    int posX{0};\r\n    int posY{0};\r\n};\r\n\r\n//Spielzustandsklassen\r\nclass Spielzustand{\r\npublic:\r\n    int spielbreite{0};\r\n    int spielhoehe{0};\r\n    vector<Schlangenglied> schlange;\r\n    Position futterPosition{0,0};\r\n    int punktzahl{0};\r\n    bool gameOver{false};\r\n    bool hatGeradeGefressen{false};\r\n};\r\n\r\n// Prüft die Eingabe und gibt die Werte fürs Spielfeld zurück\r\nint pruefeEingabewert() {\r\n    int eingabewert;\r\n    if (!(cin >> eingabewert)) throw EingabeFehler{};\r\n    if (eingabewert < 3 || eingabewert > 25) throw BereichsFehler{};\r\n    return eingabewert;\r\n}\r\n\r\nvoid leseSpielfeldGroesse(Spielzustand &aktuellerSpielzustand) {\r\n    aktuellerSpielzustand.spielbreite = pruefeEingabewert();\r\n    aktuellerSpielzustand.spielhoehe = pruefeEingabewert();\r\n}\r\n\r\nPosition berechneFutterposition(const Spielzustand &aktuellerSpielzustand, const Position &kopfPosition);\r\n\r\nvoid initialisiereSpiel(Spielzustand& aktuellerSpielzustand) {\r\n    aktuellerSpielzustand.punktzahl = 0;\r\n    aktuellerSpielzustand.gameOver = false;\r\n    aktuellerSpielzustand.hatGeradeGefressen = false;\r\n    aktuellerSpielzustand.schlange.clear();\r\n    int startKopfX = (aktuellerSpielzustand.spielbreite / 2) + 1;\r\n    int startKopfY = (aktuellerSpielzustand.spielhoehe / 2) + 1;\r\n    Schlangenglied startKopf;\r\n    startKopf.posX = startKopfX;\r\n    startKopf.posY = startKopfY;\r\n    aktuellerSpielzustand.schlange.push_back(startKopf);\r\n    Position startKopfPosition{startKopfX, startKopfY};\r\n    aktuellerSpielzustand.futterPosition = berechneFutterposition(aktuellerSpielzustand, startKopfPosition);\r\n}\r\n\r\nSpielzustand erstelleNeuenSpielstand() {\r\n    Spielzustand neuerSpielzustand;\r\n    leseSpielfeldGroesse(neuerSpielzustand);\r\n    initialisiereSpiel(neuerSpielzustand);\r\n    return neuerSpielzustand;\r\n}\r\n\r\n// Berechnet Futterposition basierend auf dem aktuellen Spielstand\r\nPosition berechneFutterposition(const Spielzustand &aktuellerSpielzustand, const Position &kopfPosition) {\r\n    Position futterPosition{\r\n        ((17 * kopfPosition.posX) % aktuellerSpielzustand.spielbreite) + 1,\r\n        ((13 * kopfPosition.posY) % aktuellerSpielzustand.spielhoehe) + 1\r\n    };\r\n    auto istPositionBelegt = [&](const Position& pruefPosition) {\r\n        for (const auto &segment : aktuellerSpielzustand.schlange) {\r\n            if (segment.posX == pruefPosition.posX && segment.posY == pruefPosition.posY) return true;\r\n        }\r\n        return false;\r\n    };\r\n    int schritt = 1;\r\n    while (istPositionBelegt(futterPosition)) {\r\n        futterPosition.posX = ((futterPosition.posX + schritt - 1) % aktuellerSpielzustand.spielbreite) + 1;\r\n        futterPosition.posY = ((futterPosition.posY + schritt - 1) % aktuellerSpielzustand.spielhoehe) + 1;\r\n        ++schritt;\r\n        if (schritt > aktuellerSpielzustand.spielbreite * aktuellerSpielzustand.spielhoehe) break;\r\n    }\r\n    return futterPosition;\r\n}\r\n\r\n// Druckt den aktuellen Spielzustand (liest nur Werte ein)\r\nvoid druckeSpielfeld(const Spielzustand &aktuellerSpielzustand) {\r\n    int feldBreite = aktuellerSpielzustand.spielbreite;\r\n    int feldHoehe = aktuellerSpielzustand.spielhoehe;\r\n    for (int reiheIndex = 0; reiheIndex < feldHoehe + 2; ++reiheIndex) {\r\n        if (reiheIndex == 0 || reiheIndex == feldHoehe + 1) {\r\n            cout << \"|\" << string(feldBreite, '-') << \"|\\n\";\r\n        } else {\r\n            int zeilenKoordinate = reiheIndex;\r\n            cout << \"|\";\r\n            for (int spaltenIndex = 1; spaltenIndex <= feldBreite; ++spaltenIndex) {\r\n                bool feldGedruckt = false;\r\n                if (!aktuellerSpielzustand.schlange.empty()\r\n                    && aktuellerSpielzustand.schlange.front().posX == spaltenIndex\r\n                    && aktuellerSpielzustand.schlange.front().posY == zeilenKoordinate) {\r\n                    cout << 'O';\r\n                    feldGedruckt = true;\r\n                } else if (!feldGedruckt && aktuellerSpielzustand.futterPosition.posX == spaltenIndex && aktuellerSpielzustand.futterPosition.posY == zeilenKoordinate) {\r\n                    cout << '#';\r\n                    feldGedruckt = true;\r\n                } else {\r\n                    for (size_t segmentIndex = 1; segmentIndex < aktuellerSpielzustand.schlange.size(); ++segmentIndex) {\r\n                        if (aktuellerSpielzustand.schlange[segmentIndex].posX == spaltenIndex && aktuellerSpielzustand.schlange[segmentIndex].posY == zeilenKoordinate) {\r\n                            cout << 'o';\r\n                            feldGedruckt = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (!feldGedruckt) cout << ' ';\r\n            }\r\n            cout << \"|\\n\";\r\n        }\r\n    }\r\n    cout << \"Punktzahl: \" << aktuellerSpielzustand.punktzahl << \"\\n\";\r\n}\r\n\r\n// Liest die Steuerung ein und validiert sie\r\nchar leseSteuerung() {\r\n    char steuerungsEingabe;\r\n    if (!(cin >> steuerungsEingabe)) return 'q';\r\n    if (steuerungsEingabe == 'w' || steuerungsEingabe == 'a' || steuerungsEingabe == 's' || steuerungsEingabe == 'd' || steuerungsEingabe == 'q') {\r\n        return steuerungsEingabe;\r\n    }\r\n    throw UnzulaessigeEingabe{};\r\n}\r\n\r\n// Bewegt die Schlange im aktuellen Zustand\r\nvoid bewegeSchlange(Spielzustand& aktuellerSpielzustand, char steuerungsCode) {\r\n    if (steuerungsCode == 'q') {\r\n        aktuellerSpielzustand.gameOver = true;\r\n        return;\r\n    }\r\n    Schlangenglied aktuellesKopfSegment = aktuellerSpielzustand.schlange.front();\r\n    Position neueKopfPosition{aktuellesKopfSegment.posX, aktuellesKopfSegment.posY};\r\n    if (steuerungsCode == 'w') neueKopfPosition.posY -= 1;\r\n    else if (steuerungsCode == 's') neueKopfPosition.posY += 1;\r\n    else if (steuerungsCode == 'a') neueKopfPosition.posX -= 1;\r\n    else if (steuerungsCode == 'd') neueKopfPosition.posX += 1;\r\n    if (neueKopfPosition.posX < 1 || neueKopfPosition.posX > aktuellerSpielzustand.spielbreite\r\n        || neueKopfPosition.posY < 1 || neueKopfPosition.posY > aktuellerSpielzustand.spielhoehe) {\r\n        aktuellerSpielzustand.gameOver = true;\r\n        return;\r\n    }\r\n    bool tailBleibtBeiDieserBewegung = aktuellerSpielzustand.hatGeradeGefressen;\r\n    for (size_t segmentIndex = 0; segmentIndex < aktuellerSpielzustand.schlange.size(); ++segmentIndex) {\r\n        bool istSchwanzSegment = (segmentIndex == aktuellerSpielzustand.schlange.size() - 1);\r\n        if (!tailBleibtBeiDieserBewegung && istSchwanzSegment) continue;\r\n        const auto& segment = aktuellerSpielzustand.schlange[segmentIndex];\r\n        if (neueKopfPosition.posX == segment.posX && neueKopfPosition.posY == segment.posY) {\r\n            aktuellerSpielzustand.gameOver = true;\r\n            return;\r\n        }\r\n    }\r\n    Schlangenglied neuesKopfSegment;\r\n    neuesKopfSegment.posX = neueKopfPosition.posX;\r\n    neuesKopfSegment.posY = neueKopfPosition.posY;\r\n    aktuellerSpielzustand.schlange.insert(aktuellerSpielzustand.schlange.begin(), neuesKopfSegment);\r\n    bool hatGefressen = (neueKopfPosition.posX == aktuellerSpielzustand.futterPosition.posX && neueKopfPosition.posY == aktuellerSpielzustand.futterPosition.posY);\r\n    if (hatGefressen) {\r\n        aktuellerSpielzustand.punktzahl += 10;\r\n        aktuellerSpielzustand.futterPosition = berechneFutterposition(aktuellerSpielzustand, neueKopfPosition);\r\n        aktuellerSpielzustand.hatGeradeGefressen = true;\r\n    } else {\r\n        aktuellerSpielzustand.hatGeradeGefressen = false;\r\n    }\r\n    if (!tailBleibtBeiDieserBewegung) {\r\n        if (!aktuellerSpielzustand.schlange.empty()) aktuellerSpielzustand.schlange.pop_back();\r\n    }\r\n}\r\n\r\nint main() {\r\n    cout <<'>'<< \" \";\r\n    try {\r\n        Spielzustand aktuellerSpielzustand = erstelleNeuenSpielstand();\r\n        druckeSpielfeld(aktuellerSpielzustand);\r\n        while (!aktuellerSpielzustand.gameOver) {\r\n            try {\r\n                cout <<'>'<< \" \";\r\n                char steuerungsCode = leseSteuerung();\r\n                bewegeSchlange(aktuellerSpielzustand, steuerungsCode);\r\n                if (aktuellerSpielzustand.gameOver) break;\r\n                druckeSpielfeld(aktuellerSpielzustand);\r\n            } catch (const UnzulaessigeEingabe&) {\r\n                cout << \"Unzulaessige Eingabe! Nutze w, a, s, d zum Bewegen oder q zum Beenden.\\n\";\r\n            }\r\n        }\r\n        cout << \"Game Over! Gesamtpunktzahl: \" << aktuellerSpielzustand.punktzahl << \".\\n\";\r\n        return 0;\r\n    } catch (const BereichsFehler&) {\r\n        cout << \"Eingabe ausserhalb des zulaessigen Bereiches.\\n\";\r\n        return 1;\r\n    } catch (const EingabeFehler&) {\r\n        cout << \"Programm wegen fehlender Spielfeldeingabe beendet.\\n\";\r\n        return 1;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/3.cpp b/3.cpp
--- a/3.cpp	(revision ca224c086370ca55cafca70a09f17c90cdffc3df)
+++ b/3.cpp	(date 1764088164076)
@@ -5,64 +5,151 @@
 class EingabeFehler{};
 class UnzulaessigeEingabe{};
 
-// Schlangenklassen
-class Schlangenglied{
+// Arten der Tokens
+class TokenArt {
+    int artIndex;
+public:
+    TokenArt();
+    TokenArt(int index);
+
+    TokenArt Eingabewert();
+    TokenArt Steuerung();
+    TokenArt Beenden();
+    TokenArt Ende();
+    int value() const;
+};
+
+//Deklarationen der Einzelnen Werte
+TokenArt::TokenArt() : artIndex(3) {}
+TokenArt::TokenArt(int index) : artIndex(index) {}
+
+TokenArt TokenArt::Eingabewert() { return TokenArt(0); }
+TokenArt TokenArt::Steuerung()    { return TokenArt(1); }
+TokenArt TokenArt::Beenden()      { return TokenArt(2); }
+TokenArt TokenArt::Ende()         { return TokenArt(3); }
+
+int TokenArt::value() const { return artIndex; }
+
+// Token Klasse
+class Token {
+public:
+    TokenArt art;
+    int eingabeZahl;
+    char steuerungsZeichen;
+
+    Token();
+    Token(const TokenArt& artType, int zahl, char steuerung);
+};
+
+//Token deklaration der einzelnen Werte
+Token::Token() : art(TokenArt::Ende()), eingabeZahl(0), steuerungsZeichen(0) {}
+Token::Token(const TokenArt& artType, int zahl, char steuerung)
+    : art(artType), eingabeZahl(zahl), steuerungsZeichen(steuerung) {}
+
+
+class TokenStream {
+public:
+    TokenStream();
+    Token get();
+    void putback(const Token& token);
+private:
+    Token tokenPuffer;
+    bool istPufferVoll;
+};
+
+TokenStream::TokenStream() : tokenPuffer(), istPufferVoll(false) {}
+
+Token TokenStream::get() {
+    if (istPufferVoll) {
+        istPufferVoll = false;
+        return tokenPuffer;
+    }
+
+    char eingabeZeichen;
+    if (!(cin >> eingabeZeichen)) return Token{TokenArt::Ende(), 0, 0};
+
+    if (eingabeZeichen >= '0' && eingabeZeichen <= '9') {
+        cin.putback(eingabeZeichen);
+        int zahlWert;
+        if (!(cin >> zahlWert)) return Token{TokenArt::Ende(), 0, 0};
+        return Token{TokenArt::Eingabewert(), zahlWert, 0};
+    }
+
+    if (eingabeZeichen == 'w' || eingabeZeichen == 'a' || eingabeZeichen == 's' || eingabeZeichen == 'd')
+        return Token{TokenArt::Steuerung(), 0, eingabeZeichen};
+
+    if (eingabeZeichen == 'q') return Token{TokenArt::Beenden(), 0, 'q'};
+
+    throw UnzulaessigeEingabe{};
+}
+
+void TokenStream::putback(const Token& token) {
+    assert(!istPufferVoll);
+    tokenPuffer = token;
+    istPufferVoll = true;
+}
+
+class Schlangenglied {
 public:
-    int posX{0};
-    int posY{0};
+    int posX;
+    int posY;
 };
 
 class Position {
 public:
-    int posX{0};
-    int posY{0};
+    int posX;
+    int posY;
 };
 
-//Spielzustandsklassen
-class Spielzustand{
+
+class Spielzustand {
 public:
-    int spielbreite{0};
-    int spielhoehe{0};
+    int spielbreite;
+    int spielhoehe;
     vector<Schlangenglied> schlange;
-    Position futterPosition{0,0};
-    int punktzahl{0};
-    bool gameOver{false};
-    bool hatGeradeGefressen{false};
+    Position futterPosition;
+    int punktzahl;
+    bool gameOver;
+    bool hatGeradeGefressen;
 };
+
+// Vorwärtsdeklaration
+Position berechneFutterposition(const Spielzustand &aktuellerSpielzustand, const Position &kopfPosition);
 
 // Prüft die Eingabe und gibt die Werte fürs Spielfeld zurück
-int pruefeEingabewert() {
-    int eingabewert;
-    if (!(cin >> eingabewert)) throw EingabeFehler{};
+int pruefeEingabewert(TokenStream& tokens) {
+    Token token = tokens.get();
+    if (token.art.value() != TokenArt::Eingabewert().value()) throw EingabeFehler{};
+    int eingabewert = token.eingabeZahl;
     if (eingabewert < 3 || eingabewert > 25) throw BereichsFehler{};
     return eingabewert;
 }
 
-void leseSpielfeldGroesse(Spielzustand &aktuellerSpielzustand) {
-    aktuellerSpielzustand.spielbreite = pruefeEingabewert();
-    aktuellerSpielzustand.spielhoehe = pruefeEingabewert();
+void leseSpielfeldGroesse(Spielzustand &aktuellerSpielzustand, TokenStream& tokens) {
+    aktuellerSpielzustand.spielbreite = pruefeEingabewert(tokens);
+    aktuellerSpielzustand.spielhoehe   = pruefeEingabewert(tokens);
 }
-
-Position berechneFutterposition(const Spielzustand &aktuellerSpielzustand, const Position &kopfPosition);
 
 void initialisiereSpiel(Spielzustand& aktuellerSpielzustand) {
     aktuellerSpielzustand.punktzahl = 0;
     aktuellerSpielzustand.gameOver = false;
     aktuellerSpielzustand.hatGeradeGefressen = false;
     aktuellerSpielzustand.schlange.clear();
+
     int startKopfX = (aktuellerSpielzustand.spielbreite / 2) + 1;
     int startKopfY = (aktuellerSpielzustand.spielhoehe / 2) + 1;
     Schlangenglied startKopf;
     startKopf.posX = startKopfX;
     startKopf.posY = startKopfY;
     aktuellerSpielzustand.schlange.push_back(startKopf);
+
     Position startKopfPosition{startKopfX, startKopfY};
     aktuellerSpielzustand.futterPosition = berechneFutterposition(aktuellerSpielzustand, startKopfPosition);
 }
 
-Spielzustand erstelleNeuenSpielstand() {
+Spielzustand erstelleNeuenSpielstand(TokenStream& tokens) {
     Spielzustand neuerSpielzustand;
-    leseSpielfeldGroesse(neuerSpielzustand);
+    leseSpielfeldGroesse(neuerSpielzustand, tokens);
     initialisiereSpiel(neuerSpielzustand);
     return neuerSpielzustand;
 }
@@ -73,23 +160,26 @@
         ((17 * kopfPosition.posX) % aktuellerSpielzustand.spielbreite) + 1,
         ((13 * kopfPosition.posY) % aktuellerSpielzustand.spielhoehe) + 1
     };
+
     auto istPositionBelegt = [&](const Position& pruefPosition) {
         for (const auto &segment : aktuellerSpielzustand.schlange) {
             if (segment.posX == pruefPosition.posX && segment.posY == pruefPosition.posY) return true;
         }
         return false;
     };
+
     int schritt = 1;
-    while (istPositionBelegt(futterPosition)) {
+    int maxVersuche = aktuellerSpielzustand.spielbreite * aktuellerSpielzustand.spielhoehe;
+    if (maxVersuche <= 0) maxVersuche = 1;
+    while (istPositionBelegt(futterPosition) && schritt <= maxVersuche) {
         futterPosition.posX = ((futterPosition.posX + schritt - 1) % aktuellerSpielzustand.spielbreite) + 1;
         futterPosition.posY = ((futterPosition.posY + schritt - 1) % aktuellerSpielzustand.spielhoehe) + 1;
         ++schritt;
-        if (schritt > aktuellerSpielzustand.spielbreite * aktuellerSpielzustand.spielhoehe) break;
     }
     return futterPosition;
 }
 
-// Druckt den aktuellen Spielzustand (liest nur Werte ein)
+// Druckt den aktuellen Spielzustand
 void druckeSpielfeld(const Spielzustand &aktuellerSpielzustand) {
     int feldBreite = aktuellerSpielzustand.spielbreite;
     int feldHoehe = aktuellerSpielzustand.spielhoehe;
@@ -127,46 +217,50 @@
 }
 
 // Liest die Steuerung ein und validiert sie
-char leseSteuerung() {
-    char steuerungsEingabe;
-    if (!(cin >> steuerungsEingabe)) return 'q';
-    if (steuerungsEingabe == 'w' || steuerungsEingabe == 'a' || steuerungsEingabe == 's' || steuerungsEingabe == 'd' || steuerungsEingabe == 'q') {
-        return steuerungsEingabe;
-    }
+char leseSteuerung(TokenStream& tokens) {
+    Token token = tokens.get();
+    if (token.art.value() == TokenArt::Steuerung().value()) return token.steuerungsZeichen;
+    if (token.art.value() == TokenArt::Beenden().value() || token.art.value() == TokenArt::Ende().value()) return 'q';
     throw UnzulaessigeEingabe{};
 }
 
 // Bewegt die Schlange im aktuellen Zustand
-void bewegeSchlange(Spielzustand& aktuellerSpielzustand, char steuerungsCode) {
-    if (steuerungsCode == 'q') {
+void bewegeSchlange(Spielzustand& aktuellerSpielzustand, char steuerungsZeichen) {
+    if (steuerungsZeichen == 'q') {
         aktuellerSpielzustand.gameOver = true;
         return;
     }
+
     Schlangenglied aktuellesKopfSegment = aktuellerSpielzustand.schlange.front();
     Position neueKopfPosition{aktuellesKopfSegment.posX, aktuellesKopfSegment.posY};
-    if (steuerungsCode == 'w') neueKopfPosition.posY -= 1;
-    else if (steuerungsCode == 's') neueKopfPosition.posY += 1;
-    else if (steuerungsCode == 'a') neueKopfPosition.posX -= 1;
-    else if (steuerungsCode == 'd') neueKopfPosition.posX += 1;
+
+    if (steuerungsZeichen == 'w') neueKopfPosition.posY -= 1;
+    else if (steuerungsZeichen == 's') neueKopfPosition.posY += 1;
+    else if (steuerungsZeichen == 'a') neueKopfPosition.posX -= 1;
+    else if (steuerungsZeichen == 'd') neueKopfPosition.posX += 1;
+
     if (neueKopfPosition.posX < 1 || neueKopfPosition.posX > aktuellerSpielzustand.spielbreite
         || neueKopfPosition.posY < 1 || neueKopfPosition.posY > aktuellerSpielzustand.spielhoehe) {
         aktuellerSpielzustand.gameOver = true;
         return;
     }
-    bool tailBleibtBeiDieserBewegung = aktuellerSpielzustand.hatGeradeGefressen;
+
+    bool schwanzBleibt = aktuellerSpielzustand.hatGeradeGefressen;
     for (size_t segmentIndex = 0; segmentIndex < aktuellerSpielzustand.schlange.size(); ++segmentIndex) {
         bool istSchwanzSegment = (segmentIndex == aktuellerSpielzustand.schlange.size() - 1);
-        if (!tailBleibtBeiDieserBewegung && istSchwanzSegment) continue;
+        if (!schwanzBleibt && istSchwanzSegment) continue;
         const auto& segment = aktuellerSpielzustand.schlange[segmentIndex];
         if (neueKopfPosition.posX == segment.posX && neueKopfPosition.posY == segment.posY) {
             aktuellerSpielzustand.gameOver = true;
             return;
         }
     }
+
     Schlangenglied neuesKopfSegment;
     neuesKopfSegment.posX = neueKopfPosition.posX;
     neuesKopfSegment.posY = neueKopfPosition.posY;
     aktuellerSpielzustand.schlange.insert(aktuellerSpielzustand.schlange.begin(), neuesKopfSegment);
+
     bool hatGefressen = (neueKopfPosition.posX == aktuellerSpielzustand.futterPosition.posX && neueKopfPosition.posY == aktuellerSpielzustand.futterPosition.posY);
     if (hatGefressen) {
         aktuellerSpielzustand.punktzahl += 10;
@@ -175,21 +269,23 @@
     } else {
         aktuellerSpielzustand.hatGeradeGefressen = false;
     }
-    if (!tailBleibtBeiDieserBewegung) {
+
+    if (!schwanzBleibt) {
         if (!aktuellerSpielzustand.schlange.empty()) aktuellerSpielzustand.schlange.pop_back();
     }
 }
 
 int main() {
-    cout <<'>'<< " ";
     try {
-        Spielzustand aktuellerSpielzustand = erstelleNeuenSpielstand();
+        cout << "Gib zwei Zahlen für Spielfeldbreite und -höhe ein (jeweils 3..25), getrennt durch Leerzeichen oder Enter:\n> ";
+        TokenStream tokens;
+        Spielzustand aktuellerSpielzustand = erstelleNeuenSpielstand(tokens);
         druckeSpielfeld(aktuellerSpielzustand);
         while (!aktuellerSpielzustand.gameOver) {
             try {
-                cout <<'>'<< " ";
-                char steuerungsCode = leseSteuerung();
-                bewegeSchlange(aktuellerSpielzustand, steuerungsCode);
+                cout << "> ";
+                char steuerungsZeichen = leseSteuerung(tokens);
+                bewegeSchlange(aktuellerSpielzustand, steuerungsZeichen);
                 if (aktuellerSpielzustand.gameOver) break;
                 druckeSpielfeld(aktuellerSpielzustand);
             } catch (const UnzulaessigeEingabe&) {
Index: ../../Team/.idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../../Team/.idea/modules.xml b/../../Team/.idea/modules.xml
new file mode 100644
--- /dev/null	(date 1764011581453)
+++ b/../../Team/.idea/modules.xml	(date 1764011581453)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/Team.iml" filepath="$PROJECT_DIR$/.idea/Team.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
Index: ../../Team/.idea/Team.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../../Team/.idea/Team.iml b/../../Team/.idea/Team.iml
new file mode 100644
--- /dev/null	(date 1764011629483)
+++ b/../../Team/.idea/Team.iml	(date 1764011629483)
@@ -0,0 +1,2 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module classpath="CMake" type="CPP_MODULE" version="4" />
\ No newline at end of file
Index: ../../Team/.idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../../Team/.idea/.gitignore b/../../Team/.idea/.gitignore
new file mode 100644
--- /dev/null	(date 1764011585343)
+++ b/../../Team/.idea/.gitignore	(date 1764011585343)
@@ -0,0 +1,8 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
Index: ../../Team/Projekt_3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../../Team/Projekt_3.cpp b/../../Team/Projekt_3.cpp
new file mode 100644
--- /dev/null	(date 1764011732402)
+++ b/../../Team/Projekt_3.cpp	(date 1764011732402)
@@ -0,0 +1,36 @@
+#include "std_lib_inc.h"
+
+// Fehlerklassen: werden als Exception-Typen verwendet
+class BereichsFehler { };        // für Werte außerhalb des erlaubten Bereichs
+class EingabeFehler { };        // für nicht-numerische bzw. fehlende Eingabe
+class UnzulaessigeEingabe { };  // für ungültige Steuerungszeichen
+
+// Einzelnes Schlangenglied (Segment)
+class Schlangenglied {
+public:
+    int posX; // x-Koordinate im Spielfeld (1..breite)
+    int posY; // y-Koordinate im Spielfeld (1..hoehe)
+};
+
+// Hilfsklasse für Koordinaten/Positionen
+class Position {
+public:
+    int posX;
+    int posY;
+};
+
+// Spielzustand: zentrale Datenstruktur, hält alles Relevante
+class Spielzustand {
+public:
+    int spielbreite;                 // Spielfeldbreite
+    int spielhoehe;                  // Spielfeldhöhe
+    vector<Schlangenglied> schlange; // Liste der Segmente (kopf = index 0)
+    Position futterPosition;         // aktuelle Futterposition
+    int punktzahl;                   // aktuelle Punktzahl
+    bool gameOver;                   // Spiel beendet?
+    bool hatGeradeGefressen;         // Flag: Wachstums-Trigger nach Fressen
+};
+
+int main() {
+
+}
\ No newline at end of file
